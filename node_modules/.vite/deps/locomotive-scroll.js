import {
  Lenis
} from "./chunk-TDBVHVHE.js";
import "./chunk-DC5AMYBS.js";

// node_modules/locomotive-scroll/dist/locomotive-scroll.modern.mjs
function s() {
  return s = Object.assign ? Object.assign.bind() : function(t) {
    for (var s2 = 1; s2 < arguments.length; s2++) {
      var e2 = arguments[s2];
      for (var i2 in e2) ({}).hasOwnProperty.call(e2, i2) && (t[i2] = e2[i2]);
    }
    return t;
  }, s.apply(null, arguments);
}
var e = class {
  constructor({ scrollElements: t, rootMargin: s2 = "-1px -1px -1px -1px", root: e2 = null, IORaf: i2 }) {
    this.scrollElements = void 0, this.rootMargin = void 0, this.root = void 0, this.IORaf = void 0, this.observer = void 0, this.scrollElements = t, this.rootMargin = s2, this.root = e2, this.IORaf = i2, this._init();
  }
  _init() {
    this.observer = new IntersectionObserver((t) => {
      t.forEach((t2) => {
        const s2 = this.scrollElements.find((s3) => s3.$el === t2.target);
        t2.isIntersecting ? (s2 && (s2.isAlreadyIntersected = true), this._setInview(t2)) : s2 && s2.isAlreadyIntersected && this._setOutOfView(t2);
      });
    }, { root: this.root, rootMargin: this.rootMargin });
    for (const t of this.scrollElements) this.observe(t.$el);
  }
  destroy() {
    this.observer.disconnect();
  }
  observe(t) {
    t && this.observer.observe(t);
  }
  unobserve(t) {
    t && this.observer.unobserve(t);
  }
  _setInview(t) {
    const s2 = this.scrollElements.find((s3) => s3.$el === t.target);
    this.IORaf && (null == s2 || s2.setInteractivityOn()), !this.IORaf && (null == s2 || s2.setInview());
  }
  _setOutOfView(t) {
    const s2 = this.scrollElements.find((s3) => s3.$el === t.target);
    this.IORaf && (null == s2 || s2.setInteractivityOff()), !this.IORaf && (null == s2 || s2.setOutOfView()), null != s2 && s2.attributes.scrollRepeat || this.IORaf || this.unobserve(t.target);
  }
};
function i(t, s2, e2, i2, n2) {
  return e2 + ((n2 - t) / (s2 - t) * (i2 - e2) || 0);
}
function n(t, s2) {
  return t.reduce((t2, e2) => Math.abs(e2 - s2) < Math.abs(t2 - s2) ? e2 : t2);
}
var r = "--progress";
var l = class {
  constructor({ $el: t, id: s2, subscribeElementUpdateFn: e2, unsubscribeElementUpdateFn: i2, needRaf: n2, scrollOrientation: r2, lenisInstance: l2 }) {
    var o2, a2, c2, h, d;
    this.$el = void 0, this.id = void 0, this.needRaf = void 0, this.attributes = void 0, this.scrollOrientation = void 0, this.isAlreadyIntersected = void 0, this.intersection = void 0, this.metrics = void 0, this.currentScroll = void 0, this.translateValue = void 0, this.progress = void 0, this.lastProgress = void 0, this.isInview = void 0, this.isInteractive = void 0, this.isInFold = void 0, this.isFirstResize = void 0, this.subscribeElementUpdateFn = void 0, this.unsubscribeElementUpdateFn = void 0, this.lenisInstance = void 0, this.getWindowSize = void 0, this.getMetricsStart = void 0, this.getMetricsSize = void 0, this.startPositionHandlers = { start: (t2, s3, e3) => t2 - s3 + e3, middle: (t2, s3, e3, i3) => t2 - s3 + e3 + 0.5 * i3, end: (t2, s3, e3, i3) => t2 - s3 + e3 + i3, fold: () => 0 }, this.endPositionHandlers = { start: (t2, s3) => t2 - s3, middle: (t2, s3, e3) => t2 - s3 + 0.5 * e3, end: (t2, s3, e3) => t2 - s3 + e3 }, this.$el = t, this.id = s2, this.needRaf = n2, this.scrollOrientation = r2, this.lenisInstance = l2, this.subscribeElementUpdateFn = e2, this.unsubscribeElementUpdateFn = i2, this.attributes = { scrollClass: null != (o2 = this.$el.dataset.scrollClass) ? o2 : "is-inview", scrollOffset: null != (a2 = this.$el.dataset.scrollOffset) ? a2 : "0,0", scrollPosition: null != (c2 = this.$el.dataset.scrollPosition) ? c2 : "start,end", scrollCssProgress: void 0 !== this.$el.dataset.scrollCssProgress, scrollEventProgress: null != (h = this.$el.dataset.scrollEventProgress) ? h : null, scrollSpeed: void 0 !== this.$el.dataset.scrollSpeed ? parseFloat(this.$el.dataset.scrollSpeed) : null, scrollRepeat: void 0 !== this.$el.dataset.scrollRepeat, scrollCall: null != (d = this.$el.dataset.scrollCall) ? d : null, scrollIgnoreFold: void 0 !== this.$el.dataset.scrollIgnoreFold, scrollEnableTouchSpeed: void 0 !== this.$el.dataset.scrollEnableTouchSpeed }, this.intersection = { start: 0, end: 0 }, this.metrics = { offsetStart: 0, offsetEnd: 0, bcr: {} }, this.currentScroll = this.lenisInstance.scroll, this.translateValue = 0, this.progress = 0, this.lastProgress = null, this.isInview = false, this.isInteractive = false, this.isAlreadyIntersected = false, this.isInFold = false, this.isFirstResize = true, this.getWindowSize = "vertical" === this.scrollOrientation ? () => this.lenisInstance.dimensions.height : () => this.lenisInstance.dimensions.width, this.getMetricsStart = "vertical" === this.scrollOrientation ? (t2) => t2.top : (t2) => t2.left, this.getMetricsSize = "vertical" === this.scrollOrientation ? (t2) => t2.height : (t2) => t2.width, this._init();
  }
  _init() {
    this.needRaf && this._resize();
  }
  onResize({ currentScroll: t }) {
    this.currentScroll = t, this._resize();
  }
  onRender({ currentScroll: t, smooth: s2 }) {
    const e2 = this.getWindowSize();
    if (this.currentScroll = t, this._computeProgress(), this.attributes.scrollSpeed && !isNaN(this.attributes.scrollSpeed)) if (this.attributes.scrollEnableTouchSpeed || s2) {
      if (this.isInFold) {
        const t2 = Math.max(0, this.progress);
        this.translateValue = t2 * e2 * this.attributes.scrollSpeed * -1;
      } else {
        const t2 = i(0, 1, -1, 1, this.progress);
        this.translateValue = t2 * e2 * this.attributes.scrollSpeed * -1;
      }
      this.$el.style.transform = "vertical" === this.scrollOrientation ? `translate3d(0, ${this.translateValue}px, 0)` : `translate3d(${this.translateValue}px, 0, 0)`;
    } else this.translateValue && (this.$el.style.transform = "translate3d(0, 0, 0)"), this.translateValue = 0;
  }
  setInview() {
    if (this.isInview) return;
    this.isInview = true, this.$el.classList.add(this.attributes.scrollClass);
    const t = this._getScrollCallFrom();
    this.attributes.scrollCall && this._dispatchCall("enter", t);
  }
  setOutOfView() {
    if (!this.isInview || !this.attributes.scrollRepeat) return;
    this.isInview = false, this.$el.classList.remove(this.attributes.scrollClass);
    const t = this._getScrollCallFrom();
    this.attributes.scrollCall && this._dispatchCall("leave", t);
  }
  setInteractivityOn() {
    this.isInteractive || (this.isInteractive = true, this.subscribeElementUpdateFn(this));
  }
  setInteractivityOff() {
    this.isInteractive && (this.isInteractive = false, this.unsubscribeElementUpdateFn(this), null !== this.lastProgress && this._computeProgress(n([0, 1], this.lastProgress)));
  }
  _resize() {
    this.metrics.bcr = this.$el.getBoundingClientRect(), this._computeMetrics(), this._computeIntersection(), this.isFirstResize && (this.isFirstResize = false, this.isInFold && this.setInview());
  }
  _computeMetrics() {
    const t = this.getWindowSize(), s2 = this.getMetricsStart(this.metrics.bcr), e2 = this.getMetricsSize(this.metrics.bcr);
    this.metrics.offsetStart = this.currentScroll + s2 - this.translateValue, this.metrics.offsetEnd = this.metrics.offsetStart + e2, this.isInFold = this.metrics.offsetStart < t && !this.attributes.scrollIgnoreFold;
  }
  _computeIntersection() {
    var t, s2, e2, i2, n2, r2, l2, o2;
    const a2 = this.getWindowSize(), c2 = this.getMetricsSize(this.metrics.bcr), h = this.attributes.scrollOffset.split(","), d = null != (t = null == (s2 = h[0]) ? void 0 : s2.trim()) ? t : "0", u = null != (e2 = null == (i2 = h[1]) ? void 0 : i2.trim()) ? e2 : "0", m = this.attributes.scrollPosition.split(",");
    let v = null != (n2 = null == (r2 = m[0]) ? void 0 : r2.trim()) ? n2 : "start";
    const f = null != (l2 = null == (o2 = m[1]) ? void 0 : o2.trim()) ? l2 : "end", g = d.includes("%") ? a2 * parseInt(d.replace("%", "").trim()) * 0.01 : parseInt(d), p = u.includes("%") ? a2 * parseInt(u.replace("%", "").trim()) * 0.01 : parseInt(u);
    this.isInFold && (v = "fold");
    const I = this.startPositionHandlers[v];
    this.intersection.start = I ? I(this.metrics.offsetStart, a2, g, c2) : this.metrics.offsetStart - a2 + g;
    const b = this.endPositionHandlers[f];
    if (this.intersection.end = b ? b(this.metrics.offsetStart, p, c2) : this.metrics.offsetStart - p + c2, this.intersection.end <= this.intersection.start) switch (f) {
      case "start":
      default:
        this.intersection.end = this.intersection.start + 1;
        break;
      case "middle":
        this.intersection.end = this.intersection.start + 0.5 * c2;
        break;
      case "end":
        this.intersection.end = this.intersection.start + c2;
    }
  }
  _computeProgress(t) {
    const s2 = null != t ? t : (e2 = i(this.intersection.start, this.intersection.end, 0, 1, this.currentScroll)) < 0 ? 0 : e2 > 1 ? 1 : e2;
    var e2;
    this.progress = s2, s2 !== this.lastProgress && (this.lastProgress = s2, this.attributes.scrollCssProgress && this._setCssProgress(s2), this.attributes.scrollEventProgress && this._setCustomEventProgress(s2), s2 > 0 && s2 < 1 && this.setInview(), 0 === s2 && this.setOutOfView(), 1 === s2 && this.setOutOfView());
  }
  _setCssProgress(t = 0) {
    this.$el.style.setProperty(r, t.toString());
  }
  _setCustomEventProgress(t = 0) {
    const s2 = this.attributes.scrollEventProgress;
    if (!s2) return;
    const e2 = new CustomEvent(s2, { detail: { target: this.$el, progress: t } });
    window.dispatchEvent(e2);
  }
  _getScrollCallFrom() {
    const t = n([this.intersection.start, this.intersection.end], this.currentScroll);
    return this.intersection.start === t ? "start" : "end";
  }
  destroy() {
    this.attributes.scrollCssProgress && this.$el.style.removeProperty(r), this.attributes.scrollSpeed && this.$el.style.removeProperty("transform"), this.isInview && this.attributes.scrollClass && this.$el.classList.remove(this.attributes.scrollClass);
  }
  _dispatchCall(t, s2) {
    const e2 = this.attributes.scrollCall;
    if (!e2) return;
    const i2 = new CustomEvent(e2, { detail: { target: this.$el, way: t, from: s2 } });
    window.dispatchEvent(i2);
  }
};
var o = ["scrollOffset", "scrollPosition", "scrollCssProgress", "scrollEventProgress", "scrollSpeed"];
var a = class {
  constructor({ $el: t, triggerRootMargin: s2, rafRootMargin: e2, scrollOrientation: i2, lenisInstance: n2 }) {
    this.$scrollContainer = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.scrollElements = void 0, this.triggeredScrollElements = void 0, this.RAFScrollElements = void 0, this.scrollElementsToUpdate = void 0, this.IOTriggerInstance = void 0, this.IORafInstance = void 0, this.scrollOrientation = void 0, this.lenisInstance = void 0, t ? (this.$scrollContainer = t, this.lenisInstance = n2, this.scrollOrientation = i2, this.triggerRootMargin = null != s2 ? s2 : "-1px -1px -1px -1px", this.rafRootMargin = null != e2 ? e2 : "100% 100% 100% 100%", this.scrollElements = [], this.triggeredScrollElements = [], this.RAFScrollElements = [], this.scrollElementsToUpdate = [], this._init()) : console.error("Please provide a DOM Element as scrollContainer");
  }
  _init() {
    const t = this.$scrollContainer.querySelectorAll("[data-scroll]"), s2 = this.toElementArray(t);
    this._subscribeScrollElements(s2);
    const i2 = this.lenisInstance.options.wrapper === window ? null : this.lenisInstance.options.wrapper;
    this.IOTriggerInstance = new e({ scrollElements: [...this.triggeredScrollElements], root: i2, rootMargin: this.triggerRootMargin, IORaf: false }), this.IORafInstance = new e({ scrollElements: [...this.RAFScrollElements], root: i2, rootMargin: this.rafRootMargin, IORaf: true });
  }
  destroy() {
    this.IOTriggerInstance.destroy(), this.IORafInstance.destroy(), this._unsubscribeAllScrollElements();
  }
  onResize({ currentScroll: t }) {
    for (const s2 of this.RAFScrollElements) s2.onResize({ currentScroll: t });
  }
  onRender({ currentScroll: t, smooth: s2 }) {
    for (const e2 of this.scrollElementsToUpdate) e2.onRender({ currentScroll: t, smooth: s2 });
  }
  removeScrollElements(t) {
    const s2 = t.querySelectorAll("[data-scroll]");
    if (!s2.length) return;
    const e2 = new Set(Array.from(s2));
    for (let t2 = 0; t2 < this.triggeredScrollElements.length; t2++) {
      const s3 = this.triggeredScrollElements[t2];
      e2.has(s3.$el) && (this.IOTriggerInstance.unobserve(s3.$el), this.triggeredScrollElements.splice(t2, 1));
    }
    for (let t2 = 0; t2 < this.RAFScrollElements.length; t2++) {
      const s3 = this.RAFScrollElements[t2];
      e2.has(s3.$el) && (this.IORafInstance.unobserve(s3.$el), this.RAFScrollElements.splice(t2, 1));
    }
    s2.forEach((t2) => {
      const s3 = this.scrollElementsToUpdate.find((s4) => s4.$el === t2), e3 = this.scrollElements.find((s4) => s4.$el === t2);
      s3 && this._unsubscribeElementUpdate(s3), e3 && (this.scrollElements = this.scrollElements.filter((t3) => t3.id != e3.id));
    });
  }
  addScrollElements(t) {
    const s2 = t.querySelectorAll("[data-scroll]"), e2 = [];
    this.scrollElements.forEach((t2) => {
      e2.push(t2.id);
    });
    const i2 = Math.max(...e2, 0) + 1, n2 = this.toElementArray(s2);
    this._subscribeScrollElements(n2, i2, true);
  }
  _subscribeScrollElements(t, s2 = 0, e2 = false) {
    for (let i2 = 0; i2 < t.length; i2++) {
      const n2 = t[i2], r2 = this._checkRafNeeded(n2), o2 = new l({ $el: n2, id: s2 + i2, scrollOrientation: this.scrollOrientation, lenisInstance: this.lenisInstance, subscribeElementUpdateFn: this._subscribeElementUpdate.bind(this), unsubscribeElementUpdateFn: this._unsubscribeElementUpdate.bind(this), needRaf: r2 });
      this.scrollElements.push(o2), r2 ? (this.RAFScrollElements.push(o2), e2 && (this.IORafInstance.scrollElements.push(o2), this.IORafInstance.observe(o2.$el))) : (this.triggeredScrollElements.push(o2), e2 && (this.IOTriggerInstance.scrollElements.push(o2), this.IOTriggerInstance.observe(o2.$el)));
    }
  }
  _unsubscribeAllScrollElements() {
    for (const t of this.scrollElements) t.destroy();
    this.scrollElements = [], this.RAFScrollElements = [], this.triggeredScrollElements = [], this.scrollElementsToUpdate = [];
  }
  _subscribeElementUpdate(t) {
    this.scrollElementsToUpdate.push(t);
  }
  _unsubscribeElementUpdate(t) {
    this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter((s2) => s2.id != t.id);
  }
  toElementArray(t) {
    return Array.from(t);
  }
  _checkRafNeeded(t) {
    let s2 = [...o];
    const e2 = (t2) => {
      s2 = s2.filter((s3) => s3 !== t2);
    };
    if (t.dataset.scrollOffset) {
      if ("0,0" !== t.dataset.scrollOffset.split(",").map((t2) => t2.replace("%", "").trim()).join(",")) return true;
      e2("scrollOffset");
    } else e2("scrollOffset");
    if (t.dataset.scrollPosition) {
      if ("top,bottom" !== t.dataset.scrollPosition.trim()) return true;
      e2("scrollPosition");
    } else e2("scrollPosition");
    if (t.dataset.scrollSpeed && !isNaN(parseFloat(t.dataset.scrollSpeed))) return true;
    e2("scrollSpeed");
    for (const e3 of s2) if (e3 in t.dataset) return true;
    return false;
  }
};
var c = class {
  constructor({ lenisOptions: t = {}, triggerRootMargin: s2, rafRootMargin: e2, autoStart: i2 = true, scrollCallback: n2 = () => {
  }, initCustomTicker: r2, destroyCustomTicker: l2 } = {}) {
    this.rafPlaying = void 0, this.lenisInstance = null, this.coreInstance = null, this.lenisOptions = void 0, this.triggerRootMargin = void 0, this.rafRootMargin = void 0, this.rafInstance = void 0, this.autoStart = void 0, this.isTouchDevice = void 0, this.initCustomTicker = void 0, this.destroyCustomTicker = void 0, this._onRenderBind = void 0, this._onResizeBind = void 0, this._onScrollToBind = void 0, this._originalOnContentResize = void 0, this._originalOnWrapperResize = void 0, window.locomotiveScrollVersion = "5.0.0", Object.assign(this, { lenisOptions: t, triggerRootMargin: s2, rafRootMargin: e2, autoStart: i2, scrollCallback: n2, initCustomTicker: r2, destroyCustomTicker: l2 }), this._onRenderBind = this._onRender.bind(this), this._onScrollToBind = this._onScrollTo.bind(this), this._onResizeBind = this._onResize.bind(this), this.rafPlaying = false, this.isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0, this._init();
  }
  _init() {
    this.lenisInstance = new Lenis(s({}, this.lenisOptions)), this.scrollCallback && this.lenisInstance.on("scroll", this.scrollCallback), document.documentElement.setAttribute("data-scroll-orientation", this.lenisInstance.options.orientation), requestAnimationFrame(() => {
      this.coreInstance = new a({ $el: this.lenisInstance.rootElement, triggerRootMargin: this.triggerRootMargin, rafRootMargin: this.rafRootMargin, scrollOrientation: this.lenisInstance.options.orientation, lenisInstance: this.lenisInstance }), this._bindEvents(), this.initCustomTicker && !this.destroyCustomTicker ? console.warn("initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.") : !this.initCustomTicker && this.destroyCustomTicker && console.warn("destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble."), this.autoStart && this.start();
    });
  }
  destroy() {
    var t;
    this.stop(), this._unbindEvents(), null == (t = this.lenisInstance) || t.destroy(), requestAnimationFrame(() => {
      var t2;
      null == (t2 = this.coreInstance) || t2.destroy();
    });
  }
  _bindEvents() {
    this._bindScrollToEvents(), this.lenisInstance && (this._originalOnContentResize = this.lenisInstance.dimensions.onContentResize.bind(this.lenisInstance.dimensions), this._originalOnWrapperResize = this.lenisInstance.dimensions.onWrapperResize.bind(this.lenisInstance.dimensions), this.lenisInstance.dimensions.onContentResize = () => {
      var t;
      null == (t = this._originalOnContentResize) || t.call(this), this._onResizeBind();
    }, this.lenisInstance.dimensions.onWrapperResize = () => {
      var t;
      null == (t = this._originalOnWrapperResize) || t.call(this), this._onResizeBind();
    });
  }
  _unbindEvents() {
    this._unbindScrollToEvents(), this.lenisInstance && (this._originalOnContentResize && (this.lenisInstance.dimensions.onContentResize = this._originalOnContentResize), this._originalOnWrapperResize && (this.lenisInstance.dimensions.onWrapperResize = this._originalOnWrapperResize));
  }
  _bindScrollToEvents(t) {
    var s2;
    const e2 = t || (null == (s2 = this.lenisInstance) ? void 0 : s2.rootElement), i2 = null == e2 ? void 0 : e2.querySelectorAll("[data-scroll-to]");
    (null == i2 ? void 0 : i2.length) && i2.forEach((t2) => {
      t2.addEventListener("click", this._onScrollToBind, false);
    });
  }
  _unbindScrollToEvents(t) {
    var s2;
    const e2 = t || (null == (s2 = this.lenisInstance) ? void 0 : s2.rootElement), i2 = null == e2 ? void 0 : e2.querySelectorAll("[data-scroll-to]");
    (null == i2 ? void 0 : i2.length) && i2.forEach((t2) => {
      t2.removeEventListener("click", this._onScrollToBind, false);
    });
  }
  _onResize() {
    var t, s2, e2;
    null == (t = this.coreInstance) || t.onResize({ currentScroll: null != (s2 = null == (e2 = this.lenisInstance) ? void 0 : e2.scroll) ? s2 : 0, smooth: !this.isTouchDevice });
  }
  _onRender() {
    var t, s2, e2, i2;
    null == (t = this.lenisInstance) || t.raf(Date.now()), null == (s2 = this.coreInstance) || s2.onRender({ currentScroll: null != (e2 = null == (i2 = this.lenisInstance) ? void 0 : i2.scroll) ? e2 : 0, smooth: !this.isTouchDevice });
  }
  _onScrollTo(t) {
    var s2, e2;
    t.preventDefault();
    const i2 = null != (s2 = t.currentTarget) ? s2 : null;
    if (!i2) return;
    const n2 = i2.getAttribute("data-scroll-to-href") || i2.getAttribute("href"), r2 = i2.getAttribute("data-scroll-to-offset") || 0, l2 = i2.getAttribute("data-scroll-to-duration") || (null == (e2 = this.lenisInstance) ? void 0 : e2.options.duration);
    n2 && this.scrollTo(n2, { offset: "string" == typeof r2 ? parseInt(r2) : r2, duration: "string" == typeof l2 ? parseInt(l2) : l2 });
  }
  start() {
    var t;
    this.rafPlaying || (null == (t = this.lenisInstance) || t.start(), this.rafPlaying = true, this.initCustomTicker ? this.initCustomTicker(this._onRenderBind) : this._raf());
  }
  stop() {
    var t;
    this.rafPlaying && (null == (t = this.lenisInstance) || t.stop(), this.rafPlaying = false, this.destroyCustomTicker ? this.destroyCustomTicker(this._onRenderBind) : this.rafInstance && cancelAnimationFrame(this.rafInstance));
  }
  removeScrollElements(t) {
    var s2;
    t ? (this._unbindScrollToEvents(t), null == (s2 = this.coreInstance) || s2.removeScrollElements(t)) : console.error("Please provide a DOM Element as $oldContainer");
  }
  addScrollElements(t) {
    var s2;
    t ? (null == (s2 = this.coreInstance) || s2.addScrollElements(t), requestAnimationFrame(() => {
      this._bindScrollToEvents(t);
    })) : console.error("Please provide a DOM Element as $newContainer");
  }
  resize() {
    this._onResizeBind();
  }
  scrollTo(t, s2) {
    var e2;
    null == (e2 = this.lenisInstance) || e2.scrollTo(t, { offset: null == s2 ? void 0 : s2.offset, lerp: null == s2 ? void 0 : s2.lerp, duration: null == s2 ? void 0 : s2.duration, immediate: null == s2 ? void 0 : s2.immediate, lock: null == s2 ? void 0 : s2.lock, force: null == s2 ? void 0 : s2.force, easing: null == s2 ? void 0 : s2.easing, onComplete: null == s2 ? void 0 : s2.onComplete });
  }
  _raf() {
    this._onRenderBind(), this.rafInstance = requestAnimationFrame(() => this._raf());
  }
};
export {
  c as default
};
//# sourceMappingURL=locomotive-scroll.js.map
