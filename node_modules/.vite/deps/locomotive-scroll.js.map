{
  "version": 3,
  "sources": ["../../locomotive-scroll/core/IO.ts", "../../locomotive-scroll/utils/maths.ts", "../../locomotive-scroll/core/ScrollElement.ts", "../../locomotive-scroll/core/Core.ts", "../../locomotive-scroll/index.ts"],
  "sourcesContent": ["/**\n * Intersection Observer\n *\n * Detecting visibility of an element in the viewport.\n *\n * Features functions to:\n *\n * - Trigger inview/outOfView callbacks\n * - If the element has a requestAnimationFrame dependency, set interactivy status for the ScrollElement Class\n *\n * References:\n *\n * - {@link https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API}\n */\n\nimport type { IIOOptions } from '../types';\nimport ScrollElement from './ScrollElement';\n\nexport default class IO {\n    public scrollElements: ScrollElement[];\n    private rootMargin: string;\n    private root: HTMLElement | null;\n    private IORaf: boolean;\n    private observer!: IntersectionObserver;\n\n    constructor({\n        scrollElements,\n        rootMargin = '-1px -1px -1px -1px',\n        root = null,\n        IORaf,\n    }: IIOOptions) {\n        // Parameters\n        this.scrollElements = scrollElements;\n        this.rootMargin = rootMargin;\n        this.root = root;\n        this.IORaf = IORaf;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize Intersection Observer.\n     *\n     * @private\n     */\n    private _init() {\n        // Options\n        const observerOptions = {\n            root: this.root,\n            rootMargin: this.rootMargin,\n        };\n\n        // Callback\n        const onIntersect = (entries: IntersectionObserverEntry[]) => {\n            entries.forEach((entry) => {\n                const $targetItem: ScrollElement | undefined =\n                    this.scrollElements.find(\n                        (item) => item.$el === entry.target\n                    );\n\n                if (entry.isIntersecting) {\n                    $targetItem && ($targetItem.isAlreadyIntersected = true);\n                    this._setInview(entry);\n                } else if ($targetItem && $targetItem.isAlreadyIntersected) {\n                    this._setOutOfView(entry);\n                }\n            });\n        };\n\n        // Instance\n        this.observer = new IntersectionObserver(onIntersect, observerOptions);\n\n        // Observe each default elements\n        for (const scrollElement of this.scrollElements) {\n            const $scrollElement = scrollElement.$el;\n            this.observe($scrollElement);\n        }\n    }\n\n    /**\n     * Lifecyle - Destroy Intersection Observer.\n     */\n    public destroy() {\n        this.observer.disconnect();\n    }\n\n    /**\n     * Subscribe element to the Intersection Observer.\n     *\n     * @param {HTMLElement} $scrollElement - DOM Element to observe.\n     */\n    public observe($scrollElement: HTMLElement) {\n        if (!$scrollElement) {\n            return;\n        }\n\n        this.observer.observe($scrollElement);\n    }\n\n    /**\n     * Unsubscribe element to the Intersection Observer.\n     *\n     * @param {HTMLElement} $scrollElement - DOM Element to unobserve.\n     */\n    public unobserve($scrollElement: HTMLElement) {\n        if (!$scrollElement) {\n            return;\n        }\n\n        this.observer.unobserve($scrollElement);\n    }\n\n    /**\n     * Find ScrollElementReference instance and trigger inview callbacks.\n     *\n     * @private\n     *\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\n     */\n    private _setInview(entry: IntersectionObserverEntry) {\n        const scrollElement = this.scrollElements.find(\n            (scrollElement) => scrollElement.$el === entry.target\n        );\n\n        this.IORaf && scrollElement?.setInteractivityOn();\n        !this.IORaf && scrollElement?.setInview();\n    }\n\n    /**\n     * Find ScrollElementReference instance and trigger out of view callbacks.\n     *\n     * @private\n     *\n     * @param {IntersectionObserverEntry} entry - DOM Element to observe.\n     */\n    private _setOutOfView(entry: IntersectionObserverEntry) {\n        const scrollElement = this.scrollElements.find(\n            (scrollElement) => scrollElement.$el === entry.target\n        );\n\n        this.IORaf && scrollElement?.setInteractivityOff();\n        !this.IORaf && scrollElement?.setOutOfView();\n\n        // Unobserve if element doesn't have repeat attribute\n        if (!scrollElement?.attributes.scrollRepeat && !this.IORaf) {\n            this.unobserve(entry.target as HTMLElement);\n        }\n    }\n}\n", "// https://greensock.com/docs/v3/GSAP/gsap.utils\n\n/**\n * Clamp a value to fit within a specific range (ex: clamp(0, 100, -12) --> 0).\n *\n * @param {number} min   - Minimum value expected.\n * @param {number} max   - Maximum value expected.\n * @param {number} value - Current value.\n *\n * @returns {number} - Clamped value.\n */\nexport function clamp(min: number, max: number, value: number): number {\n    return value < min ? min : value > max ? max : value;\n}\n\n/**\n * Map one range to another (ex: mapRange(-10, 10, 0, 100, 5) --> 75).\n *\n * @param {number} inMin  - Current minimum value.\n * @param {number} inMax  - Current maximum value.\n * @param {number} outMin - Maximum value expected.\n * @param {number} outMax - Maximum value expected.\n * @param {number} value  - Current value.\n *\n * @returns {number} - New value that should be between minimum value expected and maximum value.\n */\nexport function mapRange(\n    inMin: number,\n    inMax: number,\n    outMin: number,\n    outMax: number,\n    value: number\n): number {\n    const inRange = inMax - inMin;\n    const outRange = outMax - outMin;\n    return outMin + (((value - inMin) / inRange) * outRange || 0);\n}\n\n/**\n * Map a number within a range to a progress between 0 to 1 (ex: normalize(100, 200, 150) --> 0.5).\n *\n * @param {number} min   - Current minimum value.\n * @param {number} max   - Current maximum value.\n * @param {number} value - Current value.\n *\n * @returns {number} - New value that should be between 0 and 1.\n */\nexport function normalize(min: number, max: number, value: number): number {\n    return mapRange(min, max, 0, 1, value);\n}\n\n/**\n * Get closest number from an array.\n *\n * @param {number[]} array  - Numbers array.\n * @param {number}   target - Reference value.\n *\n * @returns {number} - Closest number.\n */\nexport function closestNumber(array: number[], target: number): number {\n    return array.reduce((prev, curr) => {\n        return Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev;\n    });\n}\n", "/**\n * Scroll Element\n *\n * Give tools to compute element progress in the viewport and triggers callbacks to animate it.\n *\n * Features functions to:\n *\n * - scrollClass - Add a custom class when the element is intersected by the offset\n * - scrollOffset - Determine offsets to intersect the element\n * - scrollPosition - Determine the element positions to consider an element as intersected.\n * - scrollCssProgress - Add a specific css variable (PROGRESS_CSS_VAR) that store the scroll progress\n * - scrollEventProgress - Send scroll progress to custom event listeners.\n * - scrollSpeed - Add a scroll multiplicator to create a parallax effect\n * - scrollRepeat - Repeat the option to trigger animation each time the element is intersected\n * - scrollCall - Call a custom event when the element is intersected\n */\n\nimport type {\n    IScrollElementOptions,\n    IScrollElementAttributes,\n    IScrollElementIntersection,\n    IScrollElementMetrics,\n    IScrollElementCallbacksValues,\n    scrollOrientation,\n} from '../types';\nimport { clamp, closestNumber, normalize, mapRange } from '../utils/maths';\n\n/** Constants */\nconst INVIEW_CLASS = 'is-inview';\nconst PROGRESS_CSS_VAR = '--progress';\n\nexport default class ScrollElement {\n    public $el: HTMLElement;\n    public id: number;\n    public needRaf: boolean;\n    public attributes: IScrollElementAttributes;\n    public scrollOrientation: scrollOrientation;\n    public isAlreadyIntersected: boolean;\n\n    private intersection: IScrollElementIntersection;\n    private metrics: IScrollElementMetrics;\n    private currentScroll: number;\n    private translateValue: number;\n    private progress: number;\n    private lastProgress: number | null;\n    private isInview: boolean;\n    private isInteractive: boolean;\n    private isInFold: boolean;\n    private isFirstResize: boolean;\n\n    private subscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\n    private unsubscribeElementUpdateFn: (scrollElement: ScrollElement) => void;\n    private lenisInstance: any;\n\n    // Cached functions to avoid orientation checks every frame\n    private getWindowSize: () => number;\n    private getMetricsStart: (bcr: DOMRect) => number;\n    private getMetricsSize: (bcr: DOMRect) => number;\n\n    // Position handlers for intersection.start (includes wSize)\n    private readonly startPositionHandlers: Record<string, (offsetStart: number, wSize: number, viewport: number, size: number) => number> = {\n        'start': (offsetStart, wSize, viewport) => offsetStart - wSize + viewport,\n        'middle': (offsetStart, wSize, viewport, size) => offsetStart - wSize + viewport + size * 0.5,\n        'end': (offsetStart, wSize, viewport, size) => offsetStart - wSize + viewport + size,\n        'fold': () => 0,\n    };\n\n    // Position handlers for intersection.end (DOES NOT include wSize - critical difference)\n    private readonly endPositionHandlers: Record<string, (offsetStart: number, viewport: number, size: number) => number> = {\n        'start': (offsetStart, viewport) => offsetStart - viewport,\n        'middle': (offsetStart, viewport, size) => offsetStart - viewport + size * 0.5,\n        'end': (offsetStart, viewport, size) => offsetStart - viewport + size,\n    };\n\n    constructor({\n        $el,\n        id,\n        subscribeElementUpdateFn,\n        unsubscribeElementUpdateFn,\n        needRaf,\n        scrollOrientation,\n        lenisInstance,\n    }: IScrollElementOptions) {\n        // Scroll DOM element\n        this.$el = $el;\n        // Unique ID\n        this.id = id;\n        // RAF option\n        this.needRaf = needRaf;\n        // Scroll Direction\n        this.scrollOrientation = scrollOrientation;\n        // Lenis instance\n        this.lenisInstance = lenisInstance;\n        // Parent's callbacks\n        this.subscribeElementUpdateFn = subscribeElementUpdateFn;\n        this.unsubscribeElementUpdateFn = unsubscribeElementUpdateFn;\n\n        // Attributes\n        this.attributes = {\n            scrollClass: this.$el.dataset['scrollClass'] ?? INVIEW_CLASS,\n            scrollOffset: this.$el.dataset['scrollOffset'] ?? '0,0',\n            scrollPosition: this.$el.dataset['scrollPosition'] ?? 'start,end',\n            scrollCssProgress: this.$el.dataset['scrollCssProgress'] !== undefined,\n            scrollEventProgress:\n                this.$el.dataset['scrollEventProgress'] ?? null,\n            scrollSpeed:\n                this.$el.dataset['scrollSpeed'] !== undefined\n                    ? parseFloat(this.$el.dataset['scrollSpeed'])\n                    : null,\n            scrollRepeat: this.$el.dataset['scrollRepeat'] !== undefined,\n            scrollCall: this.$el.dataset['scrollCall'] ?? null,\n            scrollIgnoreFold: this.$el.dataset['scrollIgnoreFold'] !== undefined,\n            scrollEnableTouchSpeed:\n                this.$el.dataset['scrollEnableTouchSpeed'] !== undefined,\n        };\n\n        // Limits\n        this.intersection = {\n            start: 0,\n            end: 0,\n        };\n\n        // Metrics\n        this.metrics = {\n            offsetStart: 0,\n            offsetEnd: 0,\n            bcr: {} as DOMRect,\n        };\n\n        // Scroll Values\n        this.currentScroll = this.lenisInstance.scroll;\n\n        // Parallax\n        this.translateValue = 0;\n\n        // Progress\n        this.progress = 0;\n        this.lastProgress = null;\n\n        // Inview\n        this.isInview = false;\n        this.isInteractive = false;\n        this.isAlreadyIntersected = false;\n        this.isInFold = false;\n        this.isFirstResize = true;\n\n        // Cache orientation-dependent functions to avoid repeated conditionals\n        this.getWindowSize = this.scrollOrientation === 'vertical'\n            ? () => this.lenisInstance.dimensions.height\n            : () => this.lenisInstance.dimensions.width;\n\n        this.getMetricsStart = this.scrollOrientation === 'vertical'\n            ? (bcr: DOMRect) => bcr.top\n            : (bcr: DOMRect) => bcr.left;\n\n        this.getMetricsSize = this.scrollOrientation === 'vertical'\n            ? (bcr: DOMRect) => bcr.height\n            : (bcr: DOMRect) => bcr.width;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize progress tracking.\n     *\n     * @private\n     */\n    private _init() {\n        if (!this.needRaf) {\n            return;\n        }\n\n        // First resize to compute all values\n        this._resize();\n    }\n\n    /**\n     * Callback - Resize callback\n     */\n    public onResize({ currentScroll }: IScrollElementCallbacksValues) {\n        this.currentScroll = currentScroll;\n        this._resize();\n    }\n\n    /**\n     * Callback - RAF callback\n     */\n    public onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\n        const wSize = this.getWindowSize();\n        this.currentScroll = currentScroll;\n        this._computeProgress();\n\n        // Parallax\n        if (\n            this.attributes.scrollSpeed &&\n            !isNaN(this.attributes.scrollSpeed)\n        ) {\n            // if touch detected or smooth disabled\n            if (!this.attributes.scrollEnableTouchSpeed && !smooth) {\n                if (this.translateValue) {\n                    this.$el.style.transform = `translate3d(0, 0, 0)`;\n                }\n                this.translateValue = 0;\n\n            // if mousewheel or smooth enabled\n            } else {\n                // Check fold condition\n                if (this.isInFold) {\n                    const progress = Math.max(0, this.progress);\n                    this.translateValue =\n                        progress * wSize * this.attributes.scrollSpeed * -1;\n                } else {\n                    const progress = mapRange(0, 1, -1, 1, this.progress);\n                    this.translateValue =\n                        progress * wSize * this.attributes.scrollSpeed * -1;\n                }\n\n                this.$el.style.transform =\n                    this.scrollOrientation === 'vertical'\n                        ? `translate3d(0, ${this.translateValue}px, 0)`\n                        : `translate3d(${this.translateValue}px, 0, 0)`;\n            }\n        }\n    }\n\n    /**\n     * Inview callback\n     */\n    public setInview() {\n        if (this.isInview) {\n            return;\n        }\n\n        this.isInview = true;\n        this.$el.classList.add(this.attributes.scrollClass);\n\n        const way = 'enter';\n        const from = this._getScrollCallFrom();\n        this.attributes.scrollCall && this._dispatchCall(way, from);\n    }\n\n    /**\n     * Out of view callback\n     */\n    public setOutOfView() {\n        if (!(this.isInview && this.attributes.scrollRepeat)) {\n            return;\n        }\n\n        this.isInview = false;\n        this.$el.classList.remove(this.attributes.scrollClass);\n\n        const way = 'leave';\n        const from = this._getScrollCallFrom();\n        this.attributes.scrollCall && this._dispatchCall(way, from);\n    }\n\n    /**\n     * Switch interactivity on to subscribe the instance to the RAF\n     * and start calculations.\n     */\n    public setInteractivityOn() {\n        if (this.isInteractive) {\n            return;\n        }\n\n        this.isInteractive = true;\n        this.subscribeElementUpdateFn(this);\n    }\n\n    /**\n     * Switch interactivity off to unsubscribe the instance to the RAF\n     * and stop calculations.\n     */\n    public setInteractivityOff() {\n        if (!this.isInteractive) {\n            return;\n        }\n\n        this.isInteractive = false;\n        this.unsubscribeElementUpdateFn(this);\n\n        // Force progress to progress limit when the element is out\n        this.lastProgress !== null &&\n            this._computeProgress(closestNumber([0, 1], this.lastProgress));\n    }\n\n    /**\n     * Resize method that compute the element's values.\n     *\n     * @private\n     */\n    private _resize() {\n        this.metrics.bcr = this.$el.getBoundingClientRect();\n        this._computeMetrics();\n        this._computeIntersection();\n\n        // First resize logic\n        if (this.isFirstResize) {\n            this.isFirstResize = false;\n            // Dispatch default call if the element is in fold.\n            if (this.isInFold) {\n                this.setInview();\n            }\n        }\n    }\n\n    /**\n     * Compute element's offsets and determine if the element is in fold.\n     *\n     * @private\n     */\n    private _computeMetrics() {\n        const wSize = this.getWindowSize();\n        const metricsStart = this.getMetricsStart(this.metrics.bcr);\n        const metricsSize = this.getMetricsSize(this.metrics.bcr);\n\n        this.metrics.offsetStart =\n            this.currentScroll + metricsStart - this.translateValue;\n        this.metrics.offsetEnd = this.metrics.offsetStart + metricsSize;\n\n        if (\n            this.metrics.offsetStart < wSize &&\n            !this.attributes.scrollIgnoreFold\n        ) {\n            this.isInFold = true;\n        } else {\n            this.isInFold = false;\n        }\n    }\n\n    /**\n     * Compute intersection values depending on the context.\n     * Uses handler-based approach for cleaner, more maintainable code.\n     *\n     * @private\n     */\n    private _computeIntersection() {\n        const wSize = this.getWindowSize();\n        const metricsSize = this.getMetricsSize(this.metrics.bcr);\n\n        // Parse offset\n        const offset = this.attributes.scrollOffset.split(',');\n        const offsetStart = offset[0]?.trim() ?? '0';\n        const offsetEnd = offset[1]?.trim() ?? '0';\n\n        // Parse positions\n        const scrollPosition = this.attributes.scrollPosition.split(',');\n        let scrollPositionStart = scrollPosition[0]?.trim() ?? 'start';\n        const scrollPositionEnd = scrollPosition[1]?.trim() ?? 'end';\n\n        // Calculate viewport offsets\n        const viewportStart = offsetStart.includes('%')\n            ? wSize * parseInt(offsetStart.replace('%', '').trim()) * 0.01\n            : parseInt(offsetStart);\n        const viewportEnd = offsetEnd.includes('%')\n            ? wSize * parseInt(offsetEnd.replace('%', '').trim()) * 0.01\n            : parseInt(offsetEnd);\n\n        // Fold exception\n        if (this.isInFold) {\n            scrollPositionStart = 'fold';\n        }\n\n        // Calculate intersection.start using handlers\n        const startHandler = this.startPositionHandlers[scrollPositionStart];\n        this.intersection.start = startHandler\n            ? startHandler(this.metrics.offsetStart, wSize, viewportStart, metricsSize)\n            : this.metrics.offsetStart - wSize + viewportStart; // default fallback\n\n        // Calculate intersection.end using handlers\n        const endHandler = this.endPositionHandlers[scrollPositionEnd];\n        this.intersection.end = endHandler\n            ? endHandler(this.metrics.offsetStart, viewportEnd, metricsSize)\n            : this.metrics.offsetStart - viewportEnd + metricsSize; // default fallback\n\n        // Ensure end > start\n        if (this.intersection.end <= this.intersection.start) {\n            switch (scrollPositionEnd) {\n                case 'start':\n                    this.intersection.end = this.intersection.start + 1;\n                    break;\n                case 'middle':\n                    this.intersection.end = this.intersection.start + metricsSize * 0.5;\n                    break;\n                case 'end':\n                    this.intersection.end = this.intersection.start + metricsSize;\n                    break;\n                default:\n                    this.intersection.end = this.intersection.start + 1;\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Compute the scroll progress of the element depending\n     * on its intersection values.\n     *\n     * @private\n     *\n     * @param {number} [forcedProgress] - Value to force progress.\n     */\n    private _computeProgress(forcedProgress?: number) {\n        // Progress\n        const progress =\n            forcedProgress ??\n            clamp(\n                0,\n                1,\n                normalize(\n                    this.intersection.start,\n                    this.intersection.end,\n                    this.currentScroll\n                )\n            );\n\n        this.progress = progress;\n\n        if (progress !== this.lastProgress) {\n            this.lastProgress = progress;\n\n            // Set the element's progress to the css variable\n            this.attributes.scrollCssProgress && this._setCssProgress(progress);\n\n            // Set the element's progress to the custom event listeners\n            this.attributes.scrollEventProgress &&\n                this._setCustomEventProgress(progress);\n\n            // Logic to trigger the inview/out of view callbacks\n            progress > 0 && progress < 1 && this.setInview();\n            progress === 0 && this.setOutOfView();\n            progress === 1 && this.setOutOfView();\n        }\n    }\n\n    /**\n     * Set the element's progress to a specific css variable.\n     *\n     * @private\n     *\n     * @param {number} [currentProgress] - Progress value.\n     */\n    _setCssProgress(currentProgress = 0) {\n        this.$el.style.setProperty(\n            PROGRESS_CSS_VAR,\n            currentProgress.toString()\n        );\n    }\n\n    /**\n     * Set the element's progress to the custom event listeners.\n     *\n     * @private\n     *\n     * @param {number} [currentProgress] - Progress value.\n     */\n    _setCustomEventProgress(currentProgress = 0) {\n        const customEventName = this.attributes.scrollEventProgress;\n\n        if (!customEventName) return;\n\n        const customEvent = new CustomEvent(customEventName, {\n            detail: {\n                target: this.$el,\n                progress: currentProgress,\n            },\n        });\n        window.dispatchEvent(customEvent);\n    }\n\n    /**\n     * Function to get scroll call from.\n     *\n     * @private\n     */\n    _getScrollCallFrom() {\n        const closestIntersectionValue = closestNumber(\n            [this.intersection.start, this.intersection.end],\n            this.currentScroll\n        );\n        return this.intersection.start === closestIntersectionValue\n            ? 'start'\n            : 'end';\n    }\n\n    /**\n     * Lifecyle - Destroy and cleanup the scroll element.\n     *\n     * Removes all CSS modifications and clears references to prevent memory leaks.\n     */\n    public destroy(): void {\n        // Remove CSS variables\n        if (this.attributes.scrollCssProgress) {\n            this.$el.style.removeProperty(PROGRESS_CSS_VAR);\n        }\n\n        // Remove transform if parallax was applied\n        if (this.attributes.scrollSpeed) {\n            this.$el.style.removeProperty('transform');\n        }\n\n        // Remove class if added\n        if (this.isInview && this.attributes.scrollClass) {\n            this.$el.classList.remove(this.attributes.scrollClass);\n        }\n    }\n\n    /**\n     * Function to dispatch a custom event.\n     *\n     * @private\n     *\n     * @param {string} way - Enter or leave.\n     * @param {string} from - Start or end.\n     */\n    _dispatchCall(way: string, from: string) {\n        const customEventName = this.attributes.scrollCall;\n\n        if (!customEventName) return;\n\n        // Using CustomEvent API (https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent)\n        const customEvent = new CustomEvent(customEventName, {\n            detail: {\n                target: this.$el,\n                way,\n                from,\n            },\n        });\n        window.dispatchEvent(customEvent);\n    }\n}\n", "/**\n * Integrates Lenis with Locomotive's built-in animation system\n */\n\nimport type {\n    CoreOptions,\n    IScrollElementCallbacksValues,\n    scrollOrientation,\n} from '../types';\nimport IO from './IO';\nimport ScrollElement from './ScrollElement';\n\n/** Defined attributes that need a requestAnimationFrame */\nconst ATTRIBUTES_THAT_NEED_RAF = [\n    'scrollOffset',\n    'scrollPosition',\n    'scrollCssProgress',\n    'scrollEventProgress',\n    'scrollSpeed',\n];\n\n/** Default root margins */\nconst TRIGGER_ROOT_MARGIN = '-1px -1px -1px -1px';\nconst RAF_ROOT_MARGIN = '100% 100% 100% 100%'; // Add 100vh top/bottom && 100vw left/right to use a biggest value with data-scroll-speed\n\n/** Default scroll attribute values */\nconst DEFAULT_SCROLL_OFFSET = '0,0';\nconst DEFAULT_SCROLL_POSITION = 'top,bottom';\n\nexport default class Core {\n    private $scrollContainer!: HTMLElement;\n    private triggerRootMargin!: string;\n    private rafRootMargin!: string;\n    private scrollElements!: ScrollElement[];\n    private triggeredScrollElements!: ScrollElement[];\n    private RAFScrollElements!: ScrollElement[];\n    private scrollElementsToUpdate!: ScrollElement[];\n    private IOTriggerInstance!: IO;\n    private IORafInstance!: IO;\n    private scrollOrientation!: scrollOrientation;\n    private lenisInstance: any;\n\n    constructor({\n        $el,\n        triggerRootMargin,\n        rafRootMargin,\n        scrollOrientation,\n        lenisInstance,\n    }: CoreOptions) {\n        if (!$el) {\n            console.error('Please provide a DOM Element as scrollContainer');\n            return;\n        }\n\n        // Scroll container\n        this.$scrollContainer = $el;\n\n        // Lenis instance\n        this.lenisInstance = lenisInstance;\n\n        // Scroll Direction\n        this.scrollOrientation = scrollOrientation;\n\n        // IO Margins\n        this.triggerRootMargin = triggerRootMargin ?? TRIGGER_ROOT_MARGIN;\n        this.rafRootMargin = rafRootMargin ?? RAF_ROOT_MARGIN;\n\n        // ScrollElements arrays\n        this.scrollElements = [];\n        this.triggeredScrollElements = [];\n        this.RAFScrollElements = [];\n        this.scrollElementsToUpdate = [];\n\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize the core.\n     *\n     * @private\n     */\n    private _init() {\n        const $scrollElements =\n            this.$scrollContainer.querySelectorAll('[data-scroll]');\n\n        const $scrollElementsArr = this.toElementArray($scrollElements);\n        this._subscribeScrollElements($scrollElementsArr);\n\n        // Determine IO root (null for window, wrapper element for custom container)\n        const ioRoot = this.lenisInstance.options.wrapper === window\n            ? null\n            : this.lenisInstance.options.wrapper as HTMLElement;\n\n        // Trigger IO\n        this.IOTriggerInstance = new IO({\n            scrollElements: [...this.triggeredScrollElements],\n            root: ioRoot,\n            rootMargin: this.triggerRootMargin,\n            IORaf: false,\n        });\n\n        // Raf IO\n        this.IORafInstance = new IO({\n            scrollElements: [...this.RAFScrollElements],\n            root: ioRoot,\n            rootMargin: this.rafRootMargin,\n            IORaf: true,\n        });\n    }\n\n    /**\n     * Lifecyle - Destroy core.\n     */\n    public destroy() {\n        this.IOTriggerInstance.destroy();\n        this.IORafInstance.destroy();\n        this._unsubscribeAllScrollElements();\n    }\n\n    /**\n     * Callback - Resize callback.\n     */\n    onResize({ currentScroll }: IScrollElementCallbacksValues) {\n        for (const scrollElement of this.RAFScrollElements) {\n            scrollElement.onResize({\n                currentScroll,\n            } as IScrollElementCallbacksValues);\n        }\n    }\n\n    /**\n     * Callback - RAF callback.\n     */\n    onRender({ currentScroll, smooth }: IScrollElementCallbacksValues) {\n        for (const scrollElement of this.scrollElementsToUpdate) {\n            scrollElement.onRender({\n                currentScroll,\n                smooth,\n            } as IScrollElementCallbacksValues);\n        }\n    }\n\n    /**\n     * Remove items from lists of scroll elements and compute all new values.\n     *\n     * @param {HTMLElement} $oldContainer - HTMLElement that contains data-scroll elements to unsubscribe\n     */\n    removeScrollElements($oldContainer: HTMLElement) {\n        const $scrollElementsToRemove =\n            $oldContainer.querySelectorAll('[data-scroll]');\n\n        if (!$scrollElementsToRemove.length) return;\n\n        const $scrollElementsToRemoveSet = new Set(Array.from($scrollElementsToRemove));\n\n        // 1. Remove from IO\n        for (let index = 0; index < this.triggeredScrollElements.length; index++) {\n            const scrollElement = this.triggeredScrollElements[index];\n            if ($scrollElementsToRemoveSet.has(scrollElement.$el)) {\n                this.IOTriggerInstance.unobserve(scrollElement.$el);\n                this.triggeredScrollElements.splice(index, 1);\n            }\n        }\n\n        for (let index = 0; index < this.RAFScrollElements.length; index++) {\n            const scrollElement = this.RAFScrollElements[index];\n            if ($scrollElementsToRemoveSet.has(scrollElement.$el)) {\n                this.IORafInstance.unobserve(scrollElement.$el);\n                this.RAFScrollElements.splice(index, 1);\n            }\n        }\n\n        // 2. Remove from scrollElementsToUpdate[] and scrollElements[]\n        $scrollElementsToRemove.forEach(($scrollElement) => {\n            const targetScrollElementToUpdate =\n                this.scrollElementsToUpdate.find(\n                    (scrollElement) => scrollElement.$el === $scrollElement\n                );\n            const targetScrollElement = this.scrollElements.find(\n                (scrollElement) => scrollElement.$el === $scrollElement\n            );\n\n            if (targetScrollElementToUpdate) {\n                this._unsubscribeElementUpdate(targetScrollElementToUpdate);\n            }\n            if (targetScrollElement) {\n                this.scrollElements = this.scrollElements.filter(\n                    (scrollElementItem) =>\n                        scrollElementItem.id != targetScrollElement.id\n                );\n            }\n        });\n    }\n\n    /**\n     * Add items to lists of scroll elements and compute all new values.\n     *\n     * @param {HTMLElement} $newContainer - HTMLElement that contains data-scroll elements to subscribe\n     */\n    addScrollElements($newContainer: HTMLElement) {\n        // 3. Rebuild ScrollElements\n        const $scrollElements = $newContainer.querySelectorAll('[data-scroll]');\n\n        // 4. Get max scrollElement.id\n        const ids: number[] = [];\n        this.scrollElements.forEach((scrollElement) => {\n            ids.push(scrollElement.id);\n        });\n        const maxID = Math.max(...ids, 0);\n        const fromIndex = maxID + 1;\n        const $scrollElementsArr = this.toElementArray($scrollElements);\n        this._subscribeScrollElements(\n            $scrollElementsArr,\n            fromIndex,\n            true\n        );\n    }\n\n    /**\n     * Create a ScrollElement instance for each elements with\n     * `data-scroll` attribute.\n     *\n     * @private\n     *\n     * @param {HTMLElement[]} $scrollElements - List of elements that need\n     *     to be regarded.\n     */\n    _subscribeScrollElements(\n        $scrollElements: HTMLElement[],\n        fromIndex = 0,\n        toObserve = false\n    ) {\n        // For each scroll element create a ScrollElement instance\n        for (let index = 0; index < $scrollElements.length; index++) {\n            const $scrollElement = $scrollElements[index];\n            const needRaf = this._checkRafNeeded($scrollElement);\n\n            const scrollElementInstance = new ScrollElement({\n                $el: $scrollElement,\n                id: fromIndex + index,\n                scrollOrientation: this.scrollOrientation,\n                lenisInstance: this.lenisInstance,\n                subscribeElementUpdateFn:\n                    this._subscribeElementUpdate.bind(this),\n                unsubscribeElementUpdateFn:\n                    this._unsubscribeElementUpdate.bind(this),\n                needRaf,\n            });\n\n            // Push to common array\n            this.scrollElements.push(scrollElementInstance);\n\n            // Push to specific array\n            if (needRaf) {\n                this.RAFScrollElements.push(scrollElementInstance);\n\n                // Dynamic observe item\n                if (toObserve) {\n                    this.IORafInstance.scrollElements.push(\n                        scrollElementInstance\n                    );\n                    this.IORafInstance.observe(scrollElementInstance.$el);\n                }\n            } else {\n                this.triggeredScrollElements.push(scrollElementInstance);\n\n                // Dynamic observe item\n                if (toObserve) {\n                    this.IOTriggerInstance.scrollElements.push(\n                        scrollElementInstance\n                    );\n                    this.IOTriggerInstance.observe(scrollElementInstance.$el);\n                }\n            }\n        }\n    }\n\n    /**\n     * Clear all ScrollElement arrays.\n     *\n     * @private\n     */\n    _unsubscribeAllScrollElements() {\n        // Destroy all scroll elements to clean up CSS and references\n        for (const scrollElement of this.scrollElements) {\n            scrollElement.destroy();\n        }\n\n        this.scrollElements = [];\n        this.RAFScrollElements = [];\n        this.triggeredScrollElements = [];\n        this.scrollElementsToUpdate = [];\n    }\n\n    /**\n     * Subscribe ScrollElement instance that needs to be updated.\n     *\n     * @private\n     *\n     * @param {ScrollElement} scrollElement - ScrollElement instance inview\n     *     that needs to be updated.\n     */\n    _subscribeElementUpdate(scrollElement: ScrollElement) {\n        this.scrollElementsToUpdate.push(scrollElement);\n    }\n\n    /**\n     * Unscribe ScrollElement instance that doesn't need to be updated.\n     *\n     * @private\n     *\n     * @param {ScrollElement} scrollElement - The updated ScrollElement instance\n     *     out of view now.\n     */\n    _unsubscribeElementUpdate(scrollElement: ScrollElement) {\n        this.scrollElementsToUpdate = this.scrollElementsToUpdate.filter(\n            (scrollElementToUpdate) =>\n                scrollElementToUpdate.id != scrollElement.id\n        );\n    }\n\n    /**\n     * Convert NodeListOf<Element> to HTMLElement array.\n     *\n     * @private\n     *\n     * @param {NodeListOf<Element>} elements - The NodeList to convert.\n     *\n     * @returns {HTMLElement[]}\n     */\n    private toElementArray(elements: NodeListOf<Element>): HTMLElement[] {\n        return Array.from(elements) as HTMLElement[];\n    }\n\n    /**\n     * Check if a DOM Element need a requestAnimationFrame to be used.\n     *\n     * @private\n     *\n     * @param {HTMLElement} $scrollElement - The element that needs to be checked.\n     *\n     * @returns {boolean}\n     */\n    _checkRafNeeded($scrollElement: HTMLElement) {\n        let attributesThatNeedRaf = [...ATTRIBUTES_THAT_NEED_RAF];\n\n        // Remove utils\n        const removeAttribute = (attributeToRemove: string) => {\n            attributesThatNeedRaf = attributesThatNeedRaf.filter(\n                (attribute) => attribute !== attributeToRemove\n            );\n        };\n\n        // 1. Check scroll offset values\n        if ($scrollElement.dataset.scrollOffset) {\n            const value = $scrollElement.dataset.scrollOffset\n                .split(',')\n                .map((test) => test.replace('%', '').trim())\n                .join(',');\n            if (value !== DEFAULT_SCROLL_OFFSET) {\n                return true;\n            } else {\n                removeAttribute('scrollOffset');\n            }\n        } else {\n            removeAttribute('scrollOffset');\n        }\n\n        // 2. Check scroll position values\n        if ($scrollElement.dataset.scrollPosition) {\n            const value = $scrollElement.dataset.scrollPosition.trim();\n            if (value !== DEFAULT_SCROLL_POSITION) {\n                return true;\n            } else {\n                removeAttribute('scrollPosition');\n            }\n        } else {\n            removeAttribute('scrollPosition');\n        }\n\n        // 3. Check scroll speed values\n        if (\n            $scrollElement.dataset.scrollSpeed &&\n            !isNaN(parseFloat($scrollElement.dataset.scrollSpeed))\n        ) {\n            return true;\n        } else {\n            removeAttribute('scrollSpeed');\n        }\n\n        // 4. Check others attributes\n        for (const attribute of attributesThatNeedRaf) {\n            if (attribute in $scrollElement.dataset) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n", "import { version } from './package.json'\nimport Lenis from 'lenis';\nimport Core from './core/Core';\nimport type {\n    ILenisScrollToOptions,\n    ILenisScrollValues,\n    ILocomotiveScrollOptions,\n    lenisTargetScrollTo,\n} from './types';\nimport type { LenisOptions } from 'lenis';\n\n/**\n * Locomotive Scroll\n *\n * Detection of elements in viewport & smooth scrolling with parallax.\n *\n * Inspired by\n * {@link https://github.com/locomotivemtl/locomotive-scroll locomotive-scroll.js}\n * and built around\n * {@link https://github.com/darkroomengineering/lenis lenis.js}.\n */\n\nexport default class LocomotiveScroll {\n    public rafPlaying: boolean;\n    public lenisInstance: Lenis | null = null;\n\n    private coreInstance: Core | null = null;\n\n    private lenisOptions?: LenisOptions;\n    private triggerRootMargin?: string;\n    private rafRootMargin?: string;\n    private rafInstance?: number;\n    private autoStart?: boolean;\n    private isTouchDevice: boolean;\n    private scrollCallback?(scrollValues: ILenisScrollValues): void;\n    private initCustomTicker?: (render: () => void) => void;\n    private destroyCustomTicker?: (render: () => void) => void;\n    private _onRenderBind: () => void;\n    private _onResizeBind: () => void;\n    private _onScrollToBind: (event: MouseEvent) => void;\n    private _originalOnContentResize?: () => void;\n    private _originalOnWrapperResize?: () => void;\n\n    constructor({\n        lenisOptions = {},\n        triggerRootMargin,\n        rafRootMargin,\n        autoStart = true,\n        scrollCallback = () => {},\n        initCustomTicker,\n        destroyCustomTicker,\n    }: ILocomotiveScrollOptions = {}) {\n\n        // Set version\n        window.locomotiveScrollVersion = version;\n\n        // Get arguments\n        Object.assign(this, {\n            lenisOptions,\n            triggerRootMargin,\n            rafRootMargin,\n            autoStart,\n            scrollCallback,\n            initCustomTicker,\n            destroyCustomTicker,\n        });\n\n\n        // Binding\n        this._onRenderBind = this._onRender.bind(this);\n        this._onScrollToBind = this._onScrollTo.bind(this);\n        this._onResizeBind = this._onResize.bind(this);\n\n        // Data\n        this.rafPlaying = false;\n\n        // Detect if device has touch capability\n        this.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n\n        // Init\n        this._init();\n    }\n\n    /**\n     * Lifecyle - Initialize instance.\n     *\n     * @private\n     */\n    private _init(): void {\n        \n        // Create Lenis instance\n        this.lenisInstance = new Lenis({\n            ...this.lenisOptions\n        });\n\n        // Subscribe to scroll callback if provided\n        if (this.scrollCallback) {\n            this.lenisInstance.on('scroll', this.scrollCallback);\n        }\n\n        // Add scroll direction attribute on body\n        document.documentElement.setAttribute(\n            'data-scroll-orientation',\n            this.lenisInstance.options.orientation\n        );\n\n        requestAnimationFrame(() => {\n            // Create Core Instance\n            // lenisInstance is guaranteed to exist at this point (created above)\n            this.coreInstance = new Core({\n                $el: this.lenisInstance!.rootElement,\n                triggerRootMargin: this.triggerRootMargin,\n                rafRootMargin: this.rafRootMargin,\n                scrollOrientation: this.lenisInstance!.options.orientation,\n                lenisInstance: this.lenisInstance!,\n            });\n\n            // Bind Events\n            this._bindEvents();\n\n            // RAF warning\n            if (this.initCustomTicker && !this.destroyCustomTicker) {\n                console.warn(\n                    'initCustomTicker callback is declared, but destroyCustomTicker is not. Please pay attention. It could cause trouble.'\n                );\n            } else if (!this.initCustomTicker && this.destroyCustomTicker) {\n                console.warn(\n                    'destroyCustomTicker callback is declared, but initCustomTicker is not. Please pay attention. It could cause trouble.'\n                );\n            }\n\n            // Start RAF\n            this.autoStart && this.start();\n        });\n    }\n\n    /**\n     * Lifecyle - Destroy instance.\n     */\n    public destroy(): void {\n        // Stop raf\n        this.stop();\n        // Unbind Events\n        this._unbindEvents();\n        // Destroy Lenis\n        this.lenisInstance?.destroy();\n\n        // Destroy Core after RAF to ensure any pending Intersection Observer callbacks complete\n        // This prevents race conditions when destroy() is called while IO callbacks are queued\n        requestAnimationFrame(() => {\n            this.coreInstance?.destroy();\n        });\n    }\n\n    /**\n     * Events - Subscribe events to listen.\n     */\n    private _bindEvents() {\n        this._bindScrollToEvents();\n\n        // Hook into Lenis dimensions resize callbacks\n        // onContentResize: called when content size changes (images load, dynamic content)\n        // onWrapperResize: called when wrapper size changes (window resize, layout changes)\n        if (this.lenisInstance) {\n            this._originalOnContentResize = this.lenisInstance.dimensions.onContentResize.bind(\n                this.lenisInstance.dimensions\n            );\n            this._originalOnWrapperResize = this.lenisInstance.dimensions.onWrapperResize.bind(\n                this.lenisInstance.dimensions\n            );\n\n            this.lenisInstance.dimensions.onContentResize = () => {\n                this._originalOnContentResize?.();\n                this._onResizeBind();\n            };\n\n            this.lenisInstance.dimensions.onWrapperResize = () => {\n                this._originalOnWrapperResize?.();\n                this._onResizeBind();\n            };\n        }\n    }\n\n    /**\n     * Events - Unsubscribe listened events.\n     */\n    private _unbindEvents() {\n        this._unbindScrollToEvents();\n\n        // Restore original Lenis dimensions resize callbacks\n        if (this.lenisInstance) {\n            if (this._originalOnContentResize) {\n                this.lenisInstance.dimensions.onContentResize = this._originalOnContentResize;\n            }\n            if (this._originalOnWrapperResize) {\n                this.lenisInstance.dimensions.onWrapperResize = this._originalOnWrapperResize;\n            }\n        }\n    }\n\n    /**\n     * Events - Subscribe scrollTo events to listen.\n     */\n    private _bindScrollToEvents($container?: HTMLElement) {\n        const $rootContainer = $container\n            ? $container\n            : this.lenisInstance?.rootElement;\n        const $scrollToElements =\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\n\n        $scrollToElements?.length &&\n            $scrollToElements.forEach(($el): void => {\n                ($el as HTMLElement).addEventListener('click', this._onScrollToBind, false);\n            });\n    }\n\n    /**\n     * Events - Unsubscribe scrollTo listened events.\n     */\n    private _unbindScrollToEvents($container?: HTMLElement) {\n        const $rootContainer = $container\n            ? $container\n            : this.lenisInstance?.rootElement;\n        const $scrollToElements =\n            $rootContainer?.querySelectorAll('[data-scroll-to]');\n        $scrollToElements?.length &&\n            $scrollToElements.forEach(($el) => {\n                ($el as HTMLElement).removeEventListener('click', this._onScrollToBind, false);\n            });\n    }\n\n    /**\n     * Callback - Resize callback.\n     *\n     * Called synchronously after Lenis updates its dimensions via onContentResize/onWrapperResize.\n     * All dimension values are already up-to-date when this executes.\n     */\n    private _onResize() {\n        this.coreInstance?.onResize({\n            currentScroll: this.lenisInstance?.scroll ?? 0,\n            smooth: !this.isTouchDevice,\n        });\n    }\n\n    /**\n     * Callback - Render callback.\n     */\n    private _onRender() {\n        this.lenisInstance?.raf(Date.now());\n\n        this.coreInstance?.onRender({\n            currentScroll: this.lenisInstance?.scroll ?? 0,\n            smooth: !this.isTouchDevice,\n        });\n    }\n\n    /**\n     * Callback - Scroll To callback.\n     */\n    private _onScrollTo(event: MouseEvent) {\n        event.preventDefault();\n        const $target = (event.currentTarget as HTMLElement) ?? null;\n        if (!$target) return;\n        const target =\n            $target.getAttribute('data-scroll-to-href') ||\n            $target.getAttribute('href');\n        const offset = $target.getAttribute('data-scroll-to-offset') || 0;\n        const duration =\n            $target.getAttribute('data-scroll-to-duration') ||\n            this.lenisInstance?.options.duration\n        target &&\n            this.scrollTo(target, {\n                offset: typeof offset === 'string' ? parseInt(offset) : offset,\n                duration:\n                    typeof duration === 'string'\n                        ? parseInt(duration)\n                        : duration,\n            });\n    }\n\n    /**\n     * Start RequestAnimationFrame that active Lenis smooth and scroll progress.\n     */\n    public start(): void {\n        if (this.rafPlaying) {\n            return;\n        }\n\n        // Call lenis start method\n        this.lenisInstance?.start();\n\n        this.rafPlaying = true;\n        this.initCustomTicker\n            ? this.initCustomTicker(this._onRenderBind)\n            : this._raf();\n    }\n\n    /**\n     * Stop RequestAnimationFrame that active Lenis smooth and scroll progress.\n     */\n    public stop(): void {\n        if (!this.rafPlaying) {\n            return;\n        }\n\n        // Call lenis stop method\n        this.lenisInstance?.stop();\n\n        this.rafPlaying = false;\n        this.destroyCustomTicker\n            ? this.destroyCustomTicker(this._onRenderBind)\n            : this.rafInstance && cancelAnimationFrame(this.rafInstance);\n    }\n\n    /**\n     * Remove old scroll elements items and rebuild ScrollElements instances.\n     */\n    public removeScrollElements($oldContainer: HTMLElement): void {\n        if (!$oldContainer) {\n            console.error('Please provide a DOM Element as $oldContainer');\n            return;\n        }\n\n        this._unbindScrollToEvents($oldContainer);\n        this.coreInstance?.removeScrollElements($oldContainer);\n    }\n\n    /**\n     * Add new scroll elements items and rebuild ScrollElements instances.\n     */\n    public addScrollElements($newContainer: HTMLElement): void {\n        if (!$newContainer) {\n            console.error('Please provide a DOM Element as $newContainer');\n            return;\n        }\n\n        this.coreInstance?.addScrollElements($newContainer);\n        requestAnimationFrame(() => {\n            this._bindScrollToEvents($newContainer);\n        });\n    }\n\n    /**\n     * Trigger resize callback.\n     */\n    public resize(): void {\n        this._onResizeBind();\n    }\n\n    /**\n     * Trigger scroll to callback.\n     */\n    public scrollTo(\n        target: lenisTargetScrollTo,\n        options?: ILenisScrollToOptions\n    ): void {\n        this.lenisInstance?.scrollTo(target, {\n            offset: options?.offset,\n            lerp: options?.lerp,\n            duration: options?.duration,\n            immediate: options?.immediate,\n            lock: options?.lock,\n            force: options?.force,\n            easing: options?.easing,\n            onComplete: options?.onComplete,\n        });\n    }\n\n    /**\n     * RequestAnimationFrame that active Lenis smooth and scroll progress.\n     *\n     * @private\n     *\n     */\n    private _raf() {\n        this._onRenderBind();\n        this.rafInstance = requestAnimationFrame(() => this._raf());\n    }\n}\n\nexport * from './types';\n"],
  "mappings": "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",
  "names": ["IO", "constructor", "scrollElements", "rootMargin", "root", "IORaf", "this", "observer", "_init", "IntersectionObserver", "entries", "forEach", "entry", "$targetItem", "find", "item", "$el", "target", "isIntersecting", "isAlreadyIntersected", "_setInview", "_setOutOfView", "scrollElement", "observe", "destroy", "disconnect", "$scrollElement", "unobserve", "setInteractivityOn", "setInview", "setInteractivityOff", "setOutOfView", "attributes", "scrollRepeat", "mapRange", "inMin", "inMax", "outMin", "outMax", "value", "closestNumber", "array", "reduce", "prev", "curr", "Math", "abs", "PROGRESS_CSS_VAR", "ScrollElement", "id", "subscribeElementUpdateFn", "unsubscribeElementUpdateFn", "needRaf", "scrollOrientation", "lenisInstance", "_this$$el$dataset$scr", "_this$$el$dataset$scr2", "_this$$el$dataset$scr3", "_this$$el$dataset$scr4", "_this$$el$dataset$scr5", "intersection", "metrics", "currentScroll", "translateValue", "progress", "lastProgress", "isInview", "isInteractive", "isInFold", "isFirstResize", "getWindowSize", "getMetricsStart", "getMetricsSize", "startPositionHandlers", "start", "offsetStart", "wSize", "viewport", "middle", "size", "end", "fold", "endPositionHandlers", "scrollClass", "dataset", "scrollOffset", "scrollPosition", "scrollCssProgress", "scrollEventProgress", "scrollSpeed", "parseFloat", "scrollCall", "scrollIgnoreFold", "scrollEnableTouchSpeed", "offsetEnd", "bcr", "scroll", "dimensions", "height", "width", "top", "left", "_resize", "onResize", "onRender", "smooth", "_computeProgress", "isNaN", "max", "style", "transform", "classList", "add", "from", "_getScrollCallFrom", "_dispatchCall", "remove", "getBoundingClientRect", "_computeMetrics", "_computeIntersection", "metricsStart", "metricsSize", "_offset$0$trim", "_offset$", "_offset$1$trim", "_offset$2", "_scrollPosition$0$tri", "_scrollPosition$", "_scrollPosition$1$tri", "_scrollPosition$2", "offset", "split", "trim", "scrollPositionStart", "scrollPositionEnd", "viewportStart", "includes", "parseInt", "replace", "viewportEnd", "startHandler", "endHandler", "forcedProgress", "_setCssProgress", "_setCustomEventProgress", "currentProgress", "setProperty", "toString", "customEventName", "customEvent", "CustomEvent", "detail", "window", "dispatchEvent", "closestIntersectionValue", "removeProperty", "way", "ATTRIBUTES_THAT_NEED_RAF", "Core", "triggerRootMargin", "rafRootMargin", "$scrollContainer", "triggeredScrollElements", "RAFScrollElements", "scrollElementsToUpdate", "IOTriggerInstance", "IORafInstance", "console", "error", "$scrollElements", "querySelectorAll", "$scrollElementsArr", "toElementArray", "_subscribeScrollElements", "ioRoot", "options", "wrapper", "_unsubscribeAllScrollElements", "removeScrollElements", "$oldContainer", "$scrollElementsToRemove", "length", "$scrollElementsToRemoveSet", "Set", "Array", "index", "has", "splice", "targetScrollElementToUpdate", "targetScrollElement", "_unsubscribeElementUpdate", "filter", "scrollElementItem", "addScrollElements", "$newContainer", "ids", "push", "fromIndex", "toObserve", "_checkRafNeeded", "scrollElementInstance", "_subscribeElementUpdate", "bind", "scrollElementToUpdate", "elements", "attributesThatNeedRaf", "removeAttribute", "attributeToRemove", "attribute", "map", "test", "join", "LocomotiveScroll", "lenisOptions", "autoStart", "scrollCallback", "initCustomTicker", "destroyCustomTicker", "rafPlaying", "coreInstance", "rafInstance", "isTouchDevice", "_onRenderBind", "_onResizeBind", "_onScrollToBind", "_originalOnContentResize", "_originalOnWrapperResize", "locomotiveScrollVersion", "Object", "assign", "_onRender", "_onScrollTo", "_onResize", "navigator", "maxTouchPoints", "Lenis", "_extends", "on", "document", "documentElement", "setAttribute", "orientation", "requestAnimationFrame", "rootElement", "_bindEvents", "warn", "_this$lenisInstance", "stop", "_unbindEvents", "_this$coreInstance", "_bindScrollToEvents", "onContentResize", "onWrapperResize", "_this$_originalOnCont", "call", "_this$_originalOnWrap", "_unbindScrollToEvents", "$container", "_this$lenisInstance2", "$rootContainer", "$scrollToElements", "addEventListener", "_this$lenisInstance3", "removeEventListener", "_this$coreInstance2", "_this$lenisInstance$s", "_this$lenisInstance4", "_this$lenisInstance5", "_this$coreInstance3", "_this$lenisInstance$s2", "_this$lenisInstance6", "raf", "Date", "now", "event", "_event$currentTarget", "_this$lenisInstance7", "preventDefault", "$target", "currentTarget", "getAttribute", "duration", "scrollTo", "_this$lenisInstance8", "_raf", "_this$lenisInstance9", "cancelAnimationFrame", "_this$coreInstance4", "_this$coreInstance5", "resize", "_this$lenisInstance0", "lerp", "immediate", "lock", "force", "easing", "onComplete"]
}
